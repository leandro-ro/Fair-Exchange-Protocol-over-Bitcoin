\documentclass{cacthesis}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{tabularx}
\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\usepackage{amssymb}% http://ctan.org/pkg/amssymb
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\newcounter{protocol}
\newenvironment{protocol}[1]
  {\par\addvspace{\topsep}
   \noindent
   \tabularx{\linewidth}{@{} X @{}}
    \hline
    \refstepcounter{protocol}\textbf{Protocol \theprotocol} #1 \\
    \hline}
  { \\
    \hline
   \endtabularx
   \par\addvspace{\topsep}}

\newcommand{\sbline}{\\[.5\normalbaselineskip]}% small blank line

\begin{document}

	\frontmatter
	
	%%%%%%%%%%%%%
	%% Title page
	%%%%%%%%%%%%%
	\title{Fair Exchange Protocol over Bitcoin}
	\author{Leandro Rometsch}
	\date{October 19, 2020}
	\subject{Bachelor Thesis}
	
	\publishers{
		\small
		\begin{tabular}{r l}
			Supervisors: &  Prof. Sebastian Faust, Ph.D. & & Benjamin Schlosser
		\end{tabular}
	}
	\maketitle
	
	\tableofcontents
	
	\mainmatter
	
	\chapter{Introduction}
        %Sum up the basics of a data exchange protocol. Talk about the possibilities of smart contracts, how they can realize data exchange protocols, and why Bitcoin based smart contracts might be a good alternative to Ethereum based ones. 
        
        We describe an exchange scenario, where a buyer $B$ is willing to spend money in exchange for a product offered by seller $S$. $B$ expects the product to be in a particular condition beforehand. In a traditional setting, where both parties and the product are physically available at one place, $B$ can check for himself before paying if the product he planned to buy is the way $B$ expected it to be. If the expectation is not met, $B$ will not pay for the product - if it is, the exchange can be completed with minimal risk because both parties can be held liable. Neither $B$ nor $S$ got any disadvantage. \\
        This procedure is not trivially transferable to a digital setting - especially if digital goods are being exchanged. We assume $B$ wants to buy a digital product $d$, e.g., a song or a movie, and still got a certain expectation beforehand - this expectation is met if the predicate $\sigma\left( d\right) =1$. The dilemma is the following: Either $S$ needs to reveal its digital commodity $d'$ first to let $B$ check if $\sigma\left( d'\right) =1$, or B needs to pay beforehand without being able to inspect $d'$. Without trust among the two parties, this is undoubtedly vulnerable to fraud, and trust is not an ideal requirement in a digital setting where liability is limited. There are no security cameras, witnesses, nor is police on hand. One way to solve this dilemma is to introduce a middleman, some kind of Trusted Third Party (TTP) to the exchange - similar to Certification Authorities that issue digital certificates. The TTP can independently verify if $B$'s expectation $\sigma$ is fulfilled and secure a fair exchange. Unfortunately, a dedicated middleman comes with significant drawbacks: A service like this is usually expensive, both parties need to agree on a specific one, and the availability is questionable. \\\\
        Cryptocurrencies offer huge potential here, with their smart contracts imitating the middleman. A smart contract enables the transfer of money conditionally. The buyer and the merchant do not need to trust a single entity anymore. The only construct to trust is the decentralized \textit{blockchain} of the used cryptocurrency that evaluates a smart contract's conditions. The main difficulty here is that memory is financially limited on the \textit{blockchain} via fees. The naive approach of letting a smart contract evaluate $\sigma\left( d'\right)$, s.t. $\sigma$ is the condition to execute the monetary transfer, is only feasible if $d'$ consists of a few bytes but practically fails for larger files due to high fees - especially because digital items are usually relatively inexpensive. Another point to consider is that everything on the \textit{blockchain} is public. Therefore the naive approach is surely not advantageous for $S$. Using smart contracts that support the cheap and private exchange of larger files (as an alternative to expensive TTP) requires a different protocol design - there are good solutions out there, but more on this in the next section.   \\ 
        For a fair exchange protocol building on a particular cryptocurrency, an important aspect is the number of users the currency got. Choosing a cryptocurrency with a big user base increases the acceptance of the protocol. The most prominent technologies here are Bitcoin\footnote{https://bitcoin.org/en/} and Ethereum\footnote{https://ethereum.org/en/}. They both offer two completely distinct approaches when it comes to the construction of smart contracts. Ethereum, on the one hand, offers a powerful virtual machine that enables the formulation of complex conditions and, therefore, powerful protocols via its statically-typed and object-oriented programming language. On the other hand, Bitcoin only supports basic payment transactions based on a simple stack-based scripting language. Usually, fair exchange protocols utilizing Bitcoin are less efficient or lack a high fairness guarantee. \\\\
        This thesis aims to analyze whether it is possible to construct an efficient and cheap fair exchange protocol on top of Bitcoin rather than most other protocols achieving these properties utilizing Ethereum. A solution is particularly interesting because it would make cheap fair exchange accessible for a broader market while potentially reducing the complexity on the \textit{blockchain} itself.
        % Move this into the contribution section: Therefore, we will look into efficient Ethereum based protocols and investigate the possibility of transferring one to Bitcoin, making it accessible for a broader market.
        
        \section{Contribution}
        TODO \\
        Understanding the current concept of fairness (and the problems relating to it). \\
        What is necessary to convert a script like FairSwap onto a potentially cheaper Bitcoin variant, and why it is challenging.
        FairSwap inspired fair exchange protocol that runs cheaper on Bitcoin Script.
        
        \section{Related Work}
        % Briefly write about the interesting fair exchange protocols I reviewed in the research phase. What is the most exciting aspect of them? What can we learn from them?
        All efficient approaches to our exchange scenario have in common that they use the \textit{blockchain} as a trusted anchor and only utilize it when necessary to minimize costs. The credo is that the computation done by the participating parties locally is usually much cheaper (but not necessarily negligible) and, therefore, preferred against expensive computation done by the smart contract. \\\\
        The fair exchange protocols utilizing Bitcoin usually choose computationally demanding zero-knowledge proofs \cite{zkcp}\cite{DELGADOSEGURA2020832}, mainly because of the limitations Bitcoins smart contracts have. Other approaches, primarily Ethereum based ones, try to avoid these computational burdens while simultaneously keeping the protocol participants' fees low. FairSwap \cite{10.1145/3243734.3243857}, for example, enables buyer $B$ to prove misbehavior of a merchant afterward instead of checking $\sigma$ beforehand. Optimistic protocols like this one are advantageous because they usually only need to perform costly \textit{blockchain} interaction if fraud is suspected, making the optimistic case very cheap. The cheap optimistic case is highly desirable, especially if there is no incentive for one of the parties to cheat. One way to remove any incentive, also concerning Denial of Service (DoS) attacks, is to introduce unavoidable penalties when misbehaving. \\\\
        The crucial part of every fair exchange protocol is how to design $\sigma$, or informally speaking, the \textit{data correctness proof} s.t. $B$ can verify for itself that the product advertised by $S$ is the expected one. Different approaches do this either before or after the data exchange. Delagado et al. use a cut-and-choose technique in the first phase of their Bitcoin-based protocol \cite{DELGADOSEGURA2020832}, which splits the file into many single but still meaningful chunks. E.g., if $B$ expects to buy a specific movie from $S$, the movie is split up into chunks of its frames. A small subset of these frames is manageable for $B$ to verify beforehand, which gives (depending on the size of the subset) $B$ the confidence to proceed in the exchange. FairSwap does this the other way around by assuming a public fingerprint is available for every digital item being exchanged. After the actual file exchange, $B$ then computes the fingerprint on his own and compares it to the public one. If they do not match, $B$ can prove this to the protocol through the (TTP imitating) smart contract and get a refund. Section \ref{sec:FairSwap} goes into more details on FairSwap.

        \section{Smart Contract Environments}
        \label{sec:smartContractOptions}
        In this section, we want to take a quick look at the properties of Bitcoin, Bitcoin Cash\footnote{https://www.bitcoincash.org/}, and Ethereum in terms of using them as a smart contract foundation. \\
        In contrast to Bitcoin and Bitcoin Cash, Ethereum offers the \textit{Turing-complete} Ethereum Virtual Machine (EVM). It is similar to typical virtual machines like Java's JVM and can solve any (solvable considered) problem only limited by the given resources. Each EVM operation is given a specific price to calculate the fees the owner of a submitted smart contract must pay to the network. This fee is termed \textit{gas}, and the \textit{gas limit} restricts an Ethereum smart contract's complexity. The most popular language utilized to write smart contracts using the EVM is Solidity\footnote{https://docs.soliditylang.org/en/v0.8.0/}. Solidity is a high-level language that is influenced by C++, Python, and JavaScript. By submitting an Ethereum smart contract, a special deployment transaction is published that contains the contract's bytecode but no receiver. All public functions of a smart contract are natively accessible via the Application Binary Interface (ABI). Besides interaction via the ABI, smart contracts can communicate with other smart contracts. This enables decentralized running applications with an unlimited number of participants. Because of the flexible and powerful EVM, Ethereum, e.g., creates the foundation of the current surge of decentralized finance (DeFi) applications like Compound\footnote{http://compoundcoin.org/} and Uniswap\footnote{https://uniswap.org/}. \\
        These advanced uses of smart contracts are not possible with Bitcoin. There is no \textit{Turing-completeness}, and notably, the smart contracts cannot hold any state because all data is only temporarily stored onto a stack during execution (section \ref{sec:BTC} explains this in detail). Bitcoin chose this design intentionally to allow the efficient and independent verification of transactions. Although this design limits the on-chain possibilities, there are certainly ways to extend these possibilities by combining transactions with off-chain logic. \\
        Bitcoin Cash benefits from Bitcoins attributes by using the same underlying structure but enables additional functionality by (re-)introducing more complex operations. Storing data on Bitcoins Cash \textit{blockchain} is much cheaper and, in contrast to Bitcoin, encoding and decoding of data is possible. There are also high-level languages available that enable state simulation, e.g., Solidity inspired CashScript\footnote{https://cashscript.org/}, to build smart contracts on top of Bitcoin Cash. \\\\
        All three cryptocurrencies come with their up and downsides. Ethereum trades efficient validation for extensive functionality. Bitcoin focuses on a rudimentary stateless version of smart contracts to increase independence and validation efficiency. Bitcoin Cash builds on this and aims to find a compromise here.
            
            
    \chapter{Preliminaries}
        \section{Bitcoin}
        \label{sec:BTC}
        In 2008 Satoshi Nakamoto proposed the first practical decentralized peer-to-peer currency system (commonly known as "cryptocurrency"), named Bitcoin (BTC) \cite{nakamoto2009bitcoin}. The premise of Bitcoin is a shared data structure maintained by a decentralized network of nodes. This data structure is made out of cryptographically chained blocks, the so-called \textit{blockchain} (cf. ยง\ref{sub:Blockchain}), that miners continuously work on extending. One new block added to the \textit{blockchain} allows for a certain amount of new payment transactions and simultaneously increases the integrity of the blocks before. Other cryptocurrencies might extend their \textit{blockchain} differently. However, in Bitcoin's case, this \textit{proof-of-work} approach is used, such that the \textit{blockchain}'s integrity is guaranteed, as long as the honest nodes control more than half of the networks computational power\footnote{Computational power is necessary to generate new \textit{blockchain} blocks - it is also known as \textit{hash rate}. If one party alone controls more than half of the \textit{hash rate} new blocks can easily be manipulated}. For the computational burden the miners take, they are compensated with newly generated Bitcoins and transaction fees. The result is a self-sustaining system that is decentralized and trustable. From a high level, Bitcoin can be considered as an emulated trusted bank without a single entity controlling it. The trust in Bitcoin is high because there were practically no successful attacks yet. This fact is essential for the acceptability of a decentralized currency system because no central institution could be held liable. Simultaneously this increases the acceptance of Bitcoins \textit{blockchain} to act as an TTP through smart contracts. The users' trust rests in the \textit{proof-of-work} consensus protocol that secures the validity of transactions and prevents double-spending. \\
        It is notable that Bitcoins \textit{blockchain} only stores transactions of Bitcoins (and some metadata to secure the \textit{blockchain}) and only implicitly the user's balances. The name Bitcoin might be misleading here because there are no actual coins, only a traceable path of transactions that originate from a miner's reward. The amount of Bitcoin one person owns can be calculated by looking at every transaction this person received but did not spend jet. If a person wants to perform a Bitcoin transaction, it needs access to one key pair containing one public key and one private key. The public key is essentially the person's address, which enables him/her to receive Bitcoins. The private key is needed to send Bitcoins to other users' public keys. Because everybody can create arbitrary key-pairs without providing any personal information, Bitcoin provides some anonymity for its users. \\
        The introduction of Bitcoin, especially the \textit{blockchain} concept, kickstarted many other cryptocurrencies and \textit{blockchain}-based applications. Still, Bitcoin is the most widely accepted cryptocurrency and remains the largest by market capitalization\footnote{Source: \url{https://coinmarketcap.com/} (14.12.2020)} - followed by Ethereum and XRP.

        \subsection{BTC Transactions}
        \label{sub:BTCTx}
        
        Technically there are no Bitcoins, only transactions of a particular Bitcoin value that are either spent or unspent. Each new transaction needs at least one input transaction. The sum of the value of all input transactions determines the maximum value of the new transaction. The remaining amount of Bitcoin value inside a transaction (Bitcoin that is not targeted to an address) is used as a transaction fee. The higher the fee, the faster the transaction is being processed by the network. Once a transaction is published in a new block on the \textit{blockchain}, its input transaction(s) are considered spent. A new transaction itself is unspent until it is again used for some other valid transaction as input. Only unspent transactions can be used as an input transaction. If one of the input transactions is already spent, the new transaction is recognized as invalid and rejected by the network. \\
        The other two essential parts of every Bitcoin transaction are the out script and the witness. The out script is an cryptographic puzzle that contains the condition(s) that need to be fulfilled by somebody that wants to spend the transaction. The witness is the values that are given as input to the out script. Consequently, the out script is the lock of a transaction, and the witness is the key. Note that the witness inside a transaction is not related to its own out script - it is needed to unlock the out script of the input transaction(s). Therefore, if the user knows the correct values to fulfill the out script of an unspent transaction, it practically owns the particular Bitcoins. Take figure \ref{fig:tx1} as an example. The out script is written in Bitcoin's scripting language and is usually utilized to perform standard payments to a single Bitcoin address (\textit{P2PKH}, explained in \ref{sub:BTCScript}). More complex out scripts are possible that enable payments under a wide variety of conditions, e.g., timelocks or the signatures of multiple users.
        \begin{figure}
          \includegraphics[width=\linewidth]{images/basic_transaction_figure.png}
          \caption{Example of a Bitcoin transaction trace.}
          \label{fig:tx1}
        \end{figure}
        \\ For an efficient transaction validity check, each node stores, in addition to the \textit{blockchain} (or checkpoints of it), two transaction pools locally: The \textit{pending transaction pool} and the \textit{unspent transaction pool}. Pending transactions are valid transactions requested for execution but are not included in a \textit{blockchain} block yet. If a node receives a new valid transaction from a user, the node puts it into its \textit{pending transaction pool} and forwards it to all connected peers. Once a new block is added to the \textit{blockchain}, a node deletes all transactions the new block contains from its \textit{pending transaction pool} and updates its \textit{unspent transaction pool}. Suppose a node wants to evaluate the validity of the input transactions of a new transaction. In that case, it checks if all input transactions are available in the \textit{unspent transaction pool} - if this is not the case, the new transaction is rejected. This procedure ensures that a node does not need to search through the whole \textit{blockchain} each time a new transaction is submitted. \\

        \subsection{BTC Script}
        \label{sub:BTCScript}
        
        Bitcoin Script is the scripting language every transaction out script is formulated in. It formalizes the conditions that have to be met (given the witness as input) to spend a specific transaction. The two significant characteristics of Bitcoin Script are its \textit{Turing-incompleteness} and the stack-based evaluation. The out script's possibilities are very limited because of the \textit{Truing-incompleteness} (especially compared to the EVM). Loops or jumps are not possible. This property's advantage is that endless loops (or, in general, deadlocks) are being avoided. Therefore, attack vectors for DoS attacks are limited. Malicious parties cannot create complicated transactions and slow down the Bitcoin network. The stack-based approach makes a Bitcoin Script very efficient to be evaluated - especially storage wise. When running a script, its elements are pushed on and popped out of the stack in a Last In First Out (LIFO) manner. The script is written in postfix notation and processed from left to right; therefore, e.g., $3\ OP\_ADD \ 4$ will appear as $3\ 4\ OP\_ADD$. Any Bitcoin Script is considered valid if no opcode triggers any failure, and after the evaluation, the top item on the stack is true. \\
        Bitcoin Scripts opcodes can be divided into several categories: From constants, flow control, or stack operations over arithmetic to cryptographic ones. In table \ref{tbl:opcodes} we will list a few, to our contribution and general understanding relevant, opcodes. The full list is available at the Bitcoin Wiki\footnote{https://en.bitcoin.it/wiki/Script}. Over time, many opcodes were disabled because of security and efficiency concerns. However, it is also possible that new opcodes are added via \textit{soft forks}. A \textit{soft fork} is Bitcoin's way of improving its protocol. Anybody can propose these Bitcoin Improvement Proposals (BIP) and, if widely accepted by the network, the protocol is updated accordingly. \\\\
        Let us showcase a very common Bitcoin Script. Most Bitcoin transactions are direct transactions from one party to another (scenarios like, e.g., in figure \ref{fig:tx1}). The out script used in these cases is the Pay to Pubkey Hash (\textit{P2PKH}). Instead of including the receiver's public-key, only the hash of the receiver's public-key is deposited. The procedure supports anonymity and hinders brute-force attacks. The receiver unlocks the out script by providing his signature of the transaction and his public-key. Thereby it can be proven that the receiver owns the private-key related to the public key and indeed wants to spend this exact transaction by providing the proper signature. The \textit{P2PKH} script, is available in listing \ref{lst:p2pkh}. \textit{ScriptPubKey} is representing the cryptographic puzzle itself, while \textit{scriptSig} is describing the input parameters. Figure \ref{fig:p2pkh} showcases the stack during an exemplary successful execution step-by-step. The \textit{P2PKH} script is easily expendable to the \textit{MultiSig} script, which consequently requires multiple parties to successfully unlock the out script and spend the transaction. \\
        
        \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
        \begin{lstlisting}[language=JavaScript, basicstyle=\footnotesize, caption=Bitcoin \textit{P2PKH} script, captionpos=b, backgroundcolor=\color{backcolour}, label=lst:p2pkh]
        scriptPubKey: OP_DUP OP_HASH160 *pubKeyHash* OP_EQUALVERIFY OP_CHECKSIG
        scriptSig: <sig> <pubKey>
        \end{lstlisting} \\
        
        Besides the \textit{P2PKH} and the \textit{MultiSig} script, numerous other powerful (but less popular) scripts exist. Especially interesting for exchange protocols are Hash-Lock scripts. These enable to challenge a potential receiver to provide some data that results in the hardcoded hash (in exchange for the Bitcoin value). Be aware that transactions like this are not necessarily secure on their own. A network node could theoretically drop the transaction and unlock it independently with the legitimate receiver's data. By combining the Hash-Lock script with the \textit{P2PKH} script, personalizing it to the receiver, the described vulnerability is fixed. \\
        The final script we want to mention here is the Hashed-Timelock script. It works accordingly to the Hash-Lock script but adds a timelock. The transaction's sender can unlock the script on his own, in the case the timelock expired and the receiver did not unlock the script by providing data matching to the hash. Usually, in Bitcoin Script, timelocks are denoted by a specific block number. If this block number is reached, the timelock is triggered. Bitcoins block numbers are easy to predict because they increment by one, and usually, it takes around 10 minutes until a new block is found. \\\\
    
        \begin{figure}
          \includegraphics[width=\linewidth]{images/p2pkh_execution_figure.png}
          \caption{Stack visualization of a Bitcoin \textit{P2PKH} script execution.}
          \label{fig:p2pkh}
        \end{figure}

        \begin{center}
            \begin{tabular}{ l | l | c | c }
             Operation  & Description & BTC & BCH \\ 
             \hline
             OP\_DUP & Duplicates an element & \cmark & \cmark \\
             OP\_HASH160 & Performs SHA-256 and then RIPEMD-160 & \cmark & \cmark  \\
             OP\_EQUAL & Compares two values and returns 1 if equal & \cmark & \cmark \\
             OP\_VERIFY & Marks execution as invalid if top value is not true & \cmark & \cmark \\
             OP\_EQUALVERIFY & Performs (1) OP\_EQUAL and (2) OP\_Verify & \cmark & \cmark \\
             OP\_CHECKSIG  & Compares the transaction hash to given signature & \cmark & \cmark \\
             OP\_CAT  & Concatenates two elements &  \xmark & \cmark \\
             OP\_XOR  & Calculates bitwise exclusive or & \xmark & \cmark \\
            \end{tabular}
            \captionof{table}{Some Bitcoin Script opcodes}
            \label{tbl:opcodes}
        \end{center}
        
        \subsection{Bitcoin Cash}
        Bitcoin Cash is a \textit{hard fork} of Bitcoin. In contrast to the usual BIPs that are implemented via \textit{soft fork}, there is the chance that the Bitcoin network is split over a major controversial BIP, which would make old blocks of the \textit{blockchain} incompatible. If no agreement is achieved and enough nodes of the network support the BIP, the part of the network agreeing could choose to extend the \textit{blockchain} with the new version on their own, while the other part of the network extends with the old protocol - resulting in a \textit{hard fork}. \\
        In 2017 this happened with Bitcoin Cash emerging from Bitcoin. Bitcoin Cash increased the block size limit from 1 MB to 8 MB. Additionally, Bitcoin Cash supporters did not support various BIPs to come, most prominently BIP141\footnote{https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki} (commonly known as \textit{SegWit}). The overall goal was to increase the possible transactions per time to use the cryptocurrency as a proper replacement for fiat money and not for investment purposes. In 2018 the block size limit increased again to 32 MB, enabling the currency to theoretically perform up-to 130 transactions per second (Bitcoin manages around 5 transactions per second). Bitcoin Cash also reintroduced various Bitcoin Script opcodes that were previously disabled by BIPs in Bitcoin. For this thesis, relevant ones are noted in table \ref{tbl:opcodes}. The extended opportunities of Bitcoin Cash over Bitcoin in the context of smart contracts are laid out in section \ref{sec:smartContractOptions}. \\\\
        Bitcoin Cash's fundamental advantage is the much higher throughput of transactions, which implicitly brings down the cost per transaction (= transaction fee). The general criticism is focused on the supposedly naive solution of increasing the block sizes instead of finding efficient off-chain solutions or improvements to the protocol itself. It is also noteworthy that Bitcoin's network contains many more nodes than Bitcoins Cash network and that Bitcoin enjoys a higher acceptance, therefore serves a broader marked.
        
        \section{FairSwap}
        \label{sec:FairSwap}
        We already mentioned that smart contracts on the \textit{blockchain} could imitate the role of a TTP. Dziembowski et al. use this characteristic in their FairSwap protocol \cite{10.1145/3243734.3243857} and offer an exemplary Ethereum based implementation\footnote{https://github.com/lEthDev/FairSwap}. Like other fair exchange protocols, the underlying goal is to guarantee the seller S to receive a payment from buyer $B$ if $S$ delivers the product $x$, s.t. the buyer's expectation formalized as the circuit (= predicate) $\sigma$ is met. This circuit must consist of simple operations to maintain efficiency. Although the TTP is imitated with the smart contract, interaction is still expensive. Especially, the evaluation of large circuits is costly. To avoid this, Dziembowski et al. observe that it is much cheaper to prove $S$'s misbehavior after the exchange and not before via verifying $\sigma(x)$ fully. While this makes the protocol very efficient, it limits FairSwap to two participating parties and makes it non-interactive. \\\\
        In the first step of the exchange, the smart contract is initialized, and $S$ is encoding $x$ (which is divided into $n$ parts) with a secret key $k$. The encoded $x$ is sent off-chain to $B$, who can then buy $k$ from $S$. The smart contract forms a trusted anchor by storing $\sigma$ and other essential values like the cryptographic fingerprint of $x$. These values are public, and after their verification, $B$ can be confident of receiving $x$ or at least a refund. Once $B$ paid and $k$ is revealed by $S$, $B$ will run the extraction procedure by decrypting encoded $x$ and verifying it with $\sigma$. Note that $\sigma$ got $n$ inputs, each one being a part of $x$. If the circuit fails, \textit{concise proof of misbehavior} is generated. This proof contains a piece of the circuit $\sigma$ that does not return an expected intermediate gate value. $B$ can submit this proof to the smart contract, verifying if the intermediate value is indeed incorrect. Therefore, if this is the case, $S$'s misbehavior is publicly proven, and $B$ automatically receives a refund. \\\\
        Notably, this exchange protocol does not use any heavy cryptographic tools like \textit{zero-knowledge proofs}. The main cryptographic primitives utilized are cryptographic hash functions, commitment schemes, and symmetric encryption. The implementation of FairSwap employs Merkle trees as an efficient to evaluate circuit. These primitives are relatively easy to compute. For a circuit with $m$ gates, the smart contract got a complexity of $O(log(m))$ and the computation costs for both parties are $O(m)$. The smart contract's \textit{gas costs} and each party's computational burden are dependent on the number of chunks $x$ is divided in (= $n$). The larger each chunk (therefore $n$ being smaller), the higher the \textit{gas costs} but, the smaller the local computational burden. While the local computational burden is independent of the exchange's success or failure, the \textit{gas costs} rise if \textit{concise proof of misbehavior} is submitted because this implies additional computation inside the smart contract. Therefore, for the pessimistic case, the \textit{gas costs} rise exponentially with an increased chunk size. \\\\
        Through the powerful EVM, it is possible to realize this protocol with only one smart contract to verify all potential \textit{concise proof of misbehavior}.
        FairSwap is further optimizable by utilizing off-chain state channels and integrating penalties into the contract, s.t. possible DoS attacks of S are monetarily limited, which could temporarily lock B's coins. These penalties also relativize the high pessimistic costs for big chunks because the optimistic case's probability rises, bringing the average costs down.
                
        \section{Building Blocks}
	        \subsection{Hash Functions}
	        \label{sub:HashFunctions}
	        Cryptographic hash functions take a string of arbitrary length as input and map it onto a fixed-sized one. We assume the hash function $H:$ $ (0, 1)^*$ $\rightarrow$ $(0, 1)^p$  is a one-way function and collision resistance (for large enough p), s.t. the outcome can informally be considered the input's unique cryptographic fingerprint. 

            \subsection{Symmetric Encryption Scheme}
            \label{sub:SymmetricEncryptionScheme}
	        The encryption scheme utilized in this thesis is a xor cipher. The secret key k is generated through a pseudo-random number generator (denoted $k$ $\leftarrow$ $(0, 1)^n$). The ciphertext is calculated by concatenating k with an index value i (denoted $k\|i$), hashing it and calculating  $c = m \ \oplus \ H(k\|i)$. We calculate the reversal $m = c \ \oplus \ H(k\|i)$ to reveal the plaintext again. \\
            Although this simple scheme is known to be vulnerable to frequency analysis and known-plaintext attacks, it suits our contribution because the encrypted data is not necessarily containing written language, and k is newly generated for every protocol run.

            \subsection{Merkle Tree}
            \label{sub:MerkleTree}
	        The Merkle tree is a data structure that enables efficient data validation. It is a fundamental building block of many popular \textit{blockchains} like Bitcoin or Ethereum. \\
            It is also called a hash tree because it utilizes cryptographic hash functions to create a tree of hash values with data chunks as leaves. The parent nodes combine their two children by concatenating and hashing again. We give an example of a Merkle tree in figure \ref{fig:merkleTreePrelims}. The root of the Merkle tree implicitly acts as a cryptographic fingerprint of all leaves combined. Note, that we hash the leaves before we create the tree. There are versions of Merkle trees that directly concatenate the leaves. \\
            We will use the algorithms \textsf{Mtree}, \textsf{Mproof}, and \textsf{Mverfy} also utilized by Dziembowski et al. in \cite{10.1145/3243734.3243857}. \textsf{Mtree} (Algorithm \ref{algo:Mtree}) generates the Merkle tree of a n-tuple $(x_1, ..., x_n)$. \textsf{Mproof} (Algorithm \ref{algo:Mproof}) takes value $i$ and generates the proof that $x_i$ is the $i$th leaf of \textsf{Mtree(x)}. \textsf{Mvrfy} (Algorithm \ref{algo:Mvrfy}) receives a Merkle root, a Merkle proof and a leaf and verifies if the leaf is indeed part of the corresponding Merkle tree based on the given proof.
            
            \begin{figure}
            \begin{center}
              \includegraphics[width=0.6\textwidth]{images/merkle_tree_figure.png}
              \caption{Merkle tree with root $H_x$ for $x = (x_1, x_2, x_3, x_4)$.}
              \label{fig:merkleTreePrelims}
            \end{center}
            \end{figure}
        
        
        \begin{center}
        \begin{tabularx}{\textwidth}{ b{0.48\textwidth} b{0.48\textwidth} }
            \begin{algorithm}[H]
                \textbf{set} $R$\;
                 \If{$n = 1$}{
                    $label(R) = H(x_1)$\;
                 }
                 \Else {
                    $v_0^l = Mtree(x_1, ..., x_{n/2})$\;
                    $v_0^r = Mtree(x_{n/2 + 1}, ..., x_n)$\;
                    $label(R) = H(root(v_0^l)\|root(v_0^r))$\;
                 }
                \Return (MerkleTree $M$, Root $R$)\;
                \caption{Merkle tree hash \\ \textit{Mtree(}Leaves \textit{$x_1, ...,x_n$)}}
                \label{algo:Mtree}
            \end{algorithm}
            \begin{algorithm}[H]
                \textbf{set} $V = M[i]$ \;
                \ForEach{$j \in [log_2(n)]$}{
                  \textbf{set} $l_j = label$($sibling$ of $V$)\;
                  \textbf{set} $v = parent$ of $V$\;
                 }
                 
                \Return (MerkleProof $(l_1, ..., l_d)$)\;
                
                \caption{Merkle tree proof \\ \textit{Mproof(}MerkleTree $M$, Index $i$\textit{)}}
                \label{algo:Mproof}
            \end{algorithm}
     &
            \begin{algorithm}[H]
                \ForEach{$l_i \in p$}{
                    \If{$i/2^j = 0$ $ mod $ $2$}{
                    $x = H(l_k\|x)$\;
                        \If{$H($\textit{isPrgrmd}$(l_k\|x))$}{
                        \Return \perp
                        }
                    } \Else{
                    $x = H(x\|l_k)$\;
                        \If{$H($\textit{isPrgrmd}$(x\|l_k))$}{
                        \Return \perp
                        }
                    }}
                \If{$x = h$}{
                    \Return $1$\;
                 } \Else{
                    \Return $0$\;
                 }
                \caption{Merkle tree proof verification \\ \textit{Mvrfy(}Leave $x_i$, MerkleProof $p = (l_1, ..., l_d)$, \\ Root $h$\textit{)}}
                \label{algo:Mvrfy}
            \end{algorithm}
            
        \end{tabularx}
        \end{center}
        
        
        \subsection{Blockchain}
        \label{sub:Blockchain}
        
        The blockchain itself is a simple data structure consisting of cryptographically connected data chunks ("blocks"). Most prominently, it is utilized as the shared data structure of many current cryptocurrency systems like Bitcoin (cf. ยง\ref{sec:BTC}) to store all transactions in a decentralized ledger. Most notably, the data stored on the blockchain must be immutable to e.g., prevent double-spending or stealing of coins. It must be (negligibly) hard to replace, delete, or modify any block and, therefore, the included transactions. The chaining of blocks achieves immutability through cryptographic hash functions. We stress that the deeper a block is integrated into the (continuously extending) blockchain, the stronger is the immutability property of this particular block. E.g., in Bitcoin, it is recommended to wait for six confirmations (= six blocks) until a transaction is confidently regarded as integrated into the blockchain. \\
        We informally construct the following two functions to provide simplified communication with the blockchain for our protocol participants. Without loss of generality, we will consider the blockchain as a trusted ledger. We assume a transaction is considered confirmed once it is accepted and integrated into this ledger. \\\\ 
        \textsf{PublishToLedger(tx)} takes a transaction $tx$ (e.g., a Bitcoin transaction as defined in ยง\ref{sec:BTC}) and publishes it to the ledger. It returns \textit{true} if $tx$ was successfully added to the ledger and \textit{false} if $tx$ got rejected (e.g., because the \textit{out script} of $tx$ input transaction failed as described in ยง\ref{sub:BTCTx}). \\\\ 
        \textsf{IsOnLedger(tx)} will verify if a transaction $tx$ is already integrated into the ledger. If $tx$ is additionally not spend, the function will return \textit{true}. If $tx$ is not on the ledger or is already used as input for another transaction (e.g., like $T_1$ in Figure \ref{fig:tx1}), the function will return \textit{false}.



        

    \chapter{Fairness in Exchange Protocols}
        Bentov and Kumaresan state that a fair exchange protocol is a particular subcase of secure multiparty computation \cite{10.1007/978-3-662-44381-1_24}. Numerous multiparty computation protocols achieve a notion of security that is capturing a form of fairness. One common way of defining fairness, in this case, is \textit{if one party receives their expected output, then so do all} \cite{10.1007/978-3-540-79263-5_8}. Cleve showed in \cite{10.1145/12130.12168} that it is impossible to achieve this notion of fairness when there is no honest majority among the protocol participants. Let us carry this knowledge into the context of a two-party exchange protocol: At the point where there is one dishonest party involved, it is impossible to achieve the mentioned form of fairness. Consequently, it is crucial to specify acceptable alternative notions of fairness specially tailored for the two-party case.   \\\\
        The obstacle when using the idea of \textit{fairness} is that various interpretations among different points of view exist. Markowitch et al. stated that it is crucial for defining fairness in exchange protocols to focus on what fairness is and not on how to obtain it \cite{10.1007/3-540-36552-4_31}. It is obvious to claim that a \textit{fair} exchange protocol requires that no party gains a \textit{significant advantage} over the other party. Different explanations of what is meant with a \textit{significant advantage} result in different fairness notions. \\
        The primary definition commonly used among publications around fair exchange protocols (like \cite{10.1145/266420.266426} \cite{asyncOptiFairEx1998} \cite{remarksOnFairEx2000})  is the following: \textit{At the end of every exchange protocol run, either all involved parties obtain their expected information/asset, or none of them receives anything.} This definition might be satisfying in some scenarios, but \textit{advantage} is still described insufficiently and only focuses on the actual exchange result here. In other words, this definition could be interpreted as some superficial notion of fairness. \\\\
        We construct the following scenario: $B$, the buyer, and $S$, the seller, use a fair exchange protocol $P$ to trade some digital coins for a digital item. The high-level procedure of $P$ is as follows: $B$ locks up digital coins that $B$ is willing to spend for a particular digital item $d$ that satisfies the predicate $\sigma$ s.t. $\sigma\left( d\right) =1$. The digital coins can be redeemed by $S$ if $S$ can deliver a digital item $d'$ s.t. $\sigma\left( d'\right) =1$. If $S$ can do this, $B$ can be sure that $d' = d$ and both parties are satisfied. If $S$ is not responding with a matching $d'$, the previously locked-up coins will be available for $B$ again after a pre-defined timeframe $t$, and $S$ cannot claim them anymore. \\
        In the sense of the above-defined superficial notion of fairness, this protocol is fair because there are only two possible outcomes of $P$. Either the exchange succeeded, or non of the parties receives anything. 
        Although $P$ is certainly fair under this definition, $B$ got - depending on the point of view - a significant disadvantage. $B$ cannot use the coins for something else during the execution of $P$, and a malicious $S$ could use this knowledge, e.g., for a DoS attack. One could argue that this is not fair because one party got a \textit{significant advantage} over the other party. Therefore giving definitions for different notions of fairness comes hand-in-hand with defining advantage. This is, unfortunately, missing in our mentioned superficial notion of fairness. 
        
        \section{Specifying Advantage}
        While explaining \textit{advantage} in the context of fair exchange protocols, Markowitch et al. come up with three main aspects that make up different notions of fairness \cite{10.1007/3-540-36552-4_31}. (1) \textbf{General fairness}, directly relating to the items being exchanged during the protocol, s.t. \textit{at the end of every exchange protocol run, either all involved parties obtain their expected information/asset, or none of them receives anything}.  (2) \textbf{Timeliness}, relating to the ability of a single party to capture the progress of the protocol and the option to abort it at some point. (3) \textbf{Abuse-freeness}, in the sense that if there is an unsuccessful execution of the protocol, no party can show the validity of intermediate results to others. As a result, no single party alone can prove to an outside one that he has the power to terminate or complete the protocol successfully. This attribute is considered difficult to achieve (especially while preserving \textit{timeliness}), and only a few protocols attain it (e.g., \cite{Gao2008}). In general, a specific notion of fairness might consider one aspect stronger, weaker, or even irrelevant. \\
        Projecting these aspects on our protocol $P$ mentioned above: (1) is undoubtedly fulfilled because either the exchange succeeded or non of the parties receives anything. (2) is only partially fulfilled because $S$ might be able to abort by not responding, but $B$ must wait until the coins are unlocked. $B$ is also not able to capture the protocol's progress because $S$ might be preparing the transmission of $d'$ or already aborted. Either way, the protocol is time-wise limited by the pre-defined timeframe $t$. (3) is not fulfilled because there is no mechanism to stop $S$ from randomly aborting the protocol. If $S$ indeed owns $d'$ s.t. $\sigma\left( d'\right) =1$, $S$ can prove to an outside party that $S$ has the power to terminate or complete $P$ successfully, at least after $B$ locked the coins and until $B$ can unlock the coins again. $S$ can abuse $P$ for the only purpose of blocking $B$'s coins for a particular time - even if $S$ does not know $d$. 
        
        \section{Strong Fairness, Weak Fairness}
        Another common notion of fairness is \textit{Strong Fairness}, sometimes referred to as perfect fairness. Pagnia and Gaertner created an early formal definition for \textit{Strong Fairness} in exchange protocols \cite{Pagnia99onthe}. They are essentially stating that both parties expect the goods being exchanged to be in a particular condition or quantity, much like the predicate $\sigma$ of our example $P$. \textit{At the end of the protocol run, either both parties expectations are being fulfilled, or no information about the other party's respective good is gained.} This notion ensures that the exchange either succeeds or ultimately fails, with nothing in-between.
        It is worth mentioning that some publications expect from their notion of \textit{Strong Fairness} that, after a payment transaction, it must be possible for the buyer to successfully claim the original expected item in case of a dispute, without requiring the misbehaving seller to cooperate \cite{10.1007/3-540-36552-4_31}. Informally speaking: After payment, the exchange must succeed. For our imaginary protocol $P$, this is not the case and would require a different strategy. Usually, this is achieved by heavyweight Trusted Third Parties ($TTP$). This $TTP$ could take $d$ from $S$ as an initial step in $P'$ and check if the expectation $\sigma$ is fulfilled. $B$ only proceeds if the $TTP$ approves. The protocol $P'$ could then run as defined in $P$ with the small addition that if $S$ is not providing $d$ until $t$ by itself, the $TTP$ will send a copy of $d$ to $B$ and finish the exchange. However, there exist optimistic protocols using transparent Trusted Third Parties that are used to maintain this notion of \textit{Strong Fairness} \cite{10.1007/3-540-36552-4_31} \cite{6982058}. \\\\
        While in \textit{Strong Fairness} it is required that the exchange fully succeeded or failed, in \textit{Weak Fairness} this property is softened. 
        \textit{Weak Fairness} demands that it must be possible for an honest party to prove to an outside one that the opposite party received the expected item, while the complaining party did not. Although the proof is required, \textit{Weak Fairness} does not expect that the implicated dispute is resolvable. However, this information could potentially be used by some protocol to execute a refund mechanism. \\\\
        We want to stress that these two related flavors of fairness focus on the point of protocol termination. In contrast to this, the above-presented description of \textit{advantage} focuses on fairness during the protocol run itself.
        
        \section{Probabilistic Fairness}
        Finally, there are fair exchange protocols that need to merge their notion of fairness with probability. These are usually protocols that depend on techniques that offer a probability of fairness (e.g., cut-and-choose in \cite{DELGADOSEGURA2020832}) based on the chosen security parameters. We recognize \textit{Probabilistic Fairness} as a relativization to already defined notions of fairness since most definitions can be easily shifted into a probabilistic context. Let us do this for our previously mentioned superficial notion of fairness: \textit{For an adequate security parameter k, at the end of the exchange protocol run, there must be a high enough probability that either all parties obtain their expected information or non of the parties obtain anything.} \\
        To further elaborate on this, we project this again on $P$. We construct a new protocol $P''$ that replaces the previous unambiguous predicate $\sigma$ with the cut-and-choose procedure $\sigma'$ . $S$ now needs to provide a $d'$ that is split up into $n$ parts. $B$ chooses $k < n$ indices $K$. These indices are not known by $S$. For a successful exchange, $S$ needs to provide a $D'$ s.t. $\forall i\in K:\sigma'\left( D_{i}'\right) =1$. \\

		
	\chapter{Our Construction}
	   Our construction is heavily inspired by the FairSwap protocol (cf. ). The intention is to enable the buyer to prove possible misbehavior of the seller instead of forcing the seller to prove his honesty. FairSwap is doing this with concise proofs of misbehavior validated by a single (to the exchange specific) smart contract on Ethereum. Our construction utilizes Bitcoin instead. Therefore, it is limited by the Bitcoins "smart contract" possibilities (cf. ), most notably through its transactions' stateless nature. Hence, it is not possible to build one smart contract that can process all steps needed. We efficiently solve this by utilizing a few conditionally chained transactions. In the optimistic case, our construction requires two published transactions. The worst-case requires one additional published transaction.
	   
	   \section{Transaction Types}
        Let there be two parties $S$ and $B$ with $pk_S$ and $pk_B$  being their respective public key and $sig_S$ and $sig_B$ being their respective signature for a particular transaction. We define the following three transaction types utilized by our construction:
        
        \subsection{Locking}
        We define the Locking Transaction (LTX) as an extended version of a MultiSig Transaction (cf. ). To spend LTX there are two options:
        \begin{enumerate}
	        \item Valid $sig_S$ and $sig_B$ are provided to the out script. Note that these signatures are dependent on the transaction that plans to spend LTX.
	        \item Timelock $t_{LTX}$ passed and a valid $sig_S$ is provided.
        \end{enumerate}
        The intention behind 1. is that a set of already (by $S$) signed unpublished transactions is spendable by $B$ with the confidence that $S$ covers the transaction's funding with published LTX (= $S$ provides a valid input transaction with LTX). Note that $S$ is in charge of which transactions can use LTX as input by his transaction-specific signatures, but $B$'s signature is ultimately also required for spending.
        If funds are not used 2. enables $S$ to recover these after $t_{LTX}$ passed. Therefore, once the timelock expires, $B$ can no longer be confident that LTX can be used as a valid input transaction - even if a valid $sig_S$ is available to $B$.
        
        \subsection{Refund}
        De facto a single valid Refund Transaction is an concise proof of misbehavior. Additionally introduce the Lockup Tx here.
        
        \subsection{Key Exchange}
        Swap key for coins.
        
        \section{Protocol Description}
        Combine the building blocks mentioned in the Preliminaries to form a formal version of the protocol.
        
        \begin{figure}
            \begin{center}
                \includegraphics[width=\textwidth]{images/locking_refund_tx_figure.png}
              \caption{$n$ refund transactions funded by one locking transaction}
              \label{fig:lockingRefundTx}
            \end{center}
            \end{figure}
            
        \begin{center}
        \begin{tabular}{ c c }
        \begin{minipage}[t]{3.15in}
            \begin{algorithm}[H]
                \SetAlgoLined
                \ForEach{$i \in (1, ..., |\textbf{x}|)$}{
                $k_i = H(k \| i)$\;
                $ex_i = k_i \oplus x_i$\;
                }
                $\textbf{ex} = (ex_1,..., ex_{|x|})$\;
                $commit_k = H(k)$\;
                \Return $(\textbf{ex}, commit_k)$\;
                \caption{\textit{Encode($H, \textbf{x}, k$)}}
            \end{algorithm}
        \end{minipage} &  
        \begin{minipage}[t]{3.15in}
            \begin{algorithm}[H]
                \SetAlgoLined
                 \ForEach{$i \in (1, ..., |\textbf{ex}|)$}{
                  $k_i = H(k \| i)$\;
                  $x_i = k_i \oplus ex_i$\;
                 }
                 $\textbf{x} = (x_1,..., x__{|ex|})$\;
                 $M_x' = Root($\textit{MerkleTree}$(\textbf{x}))$\;
                 \If{$M_x' \neq M_x$}{
                    \ForEach{$i \in (1, ..., |\textbf{ex}|)$}{
                        \If{$x_i \notin M_x$}{
                            \Return $(\textbf{x}, i)$\;
                        }
                    }
                }
                \Return $(\textbf{x}, \perp)$\;
                \caption{\textit{Decode($H, M_x, \textbf{ex}, k$)}}
            \end{algorithm}
        \end{minipage}
        \end{tabular}
        \end{center}
            
        
        \begin{protocol}{The Fair Exchange Protocol}
        Let $H$ be an collision resistant Hash-Function, $n$ the security parameter and $m$ the chunk size. \\
        \sbline
        \textit{Public information.} $(M_x, p, pk_S, pk_B)$ = (\textit{Merkle-Root} of x, price, seller public-key, buyer public-key)
        \textit{Seller S Input.} $(c, \textbf{x} = (x_1, ..., x_c) \in (\{0,1\}^m)^c)$ = (Number of chunks, item)
        \sbline
        \textit{Buyer B Input.} $()$
        \sbline
        \textit{The protocol:}
        \sbline
        \textbf{Setup:}
          \begin{enumerate}
            \item S generates secret key $k$ $\leftarrow$ $(0, 1)^n$ uniformly at random.
            
            \item S computes $(\textbf{ex} = (ex_1, ..., ex_c), commit_k)$ $\leftarrow$ \textsf{Encode($H, $}\textbf{x}\textsf{$, k$)}.
            
            \item S creates Locking-Transaction $LTX$ $\leftarrow$ \textsf{GenLockingTx($pk_S, pk_B, p$)}.
            
            \item For each $i \in (1, ..., c)$, S creates a new Refund-Transaction $SRT_i$ $\leftarrow$ \textsf{GenRefundTx($pk_S, pk_B, H(LTX), H(ex_i), i, commit_k, p$)}. S sends the set of Refund-Transactions $\textbf{SRT} = (SRT_1, ..., SRT_c)$ to B and publishes $LTX$ with \textsf{BC.post($LTX$)}
            
            \item B evaluates \textsf{ConsistencyCheck(}$\textbf{SRT}$\textsf{$, H(LTX), M_x, p, pk_S, pk_B$)} and \textsf{LockingTxCheck($LTX$)}. If one or more of the checks fail, abort the protocol.
          \end{enumerate}
          
          \textbf{Exchange:}
          \begin{enumerate}
            \item B creates Claim-Transaction $CTX$ $\leftarrow$ \textsf{CreateClaimTx($pk_S, pk_B, commit_k, p$)} and publishes it with \textsf{BC.post($CTX$)}.
            
            \item S claims $CTX$ by running \textsf{BC.claim($CTX, k$)} s.t. $H(k) = commit_k$ and earns p coins. If $CTX$ not published in time, reclaim $LTX$ via \textsf{BC.claim($LTX, \perp$)} and abort. 
          \end{enumerate}
          
          \textbf{Data Evaluation:}
          \begin{enumerate}
            \item B computes $(\textbf{x}, i)$ $\leftarrow$ \textsf{Decode($H, M_x,  $}\textbf{ex}\textsf{$, k$)}. If $i = \perp$ the exchange was successful and B concatenates all elements of $\textbf{x}$ and receives $x$. If $i \neq \perp$ B publishes $SRT_i$ via BC.post($SRT_i$) to implicitly claim $LTX$ and the exchange failed.
          \end{enumerate}
        \end{protocol}
        
        \section{Fairness Discussion}
	    Connect the findings of the Fairness section with the actual fairness of the finish protocol.
	    
	    \section{Security}
	    Informal security analysis - discuss various attack vectors.
	    
	\chapter{Implementation}
	    TODO \\
	    Details about the implementation
	    \section{Tools}
	    
	    \section{Evaluation}
	    Compare costs of protocol (computational costs \& fees) with FairSwap.
	    
	\chapter{Conclusion}
    TODO \\
	
	\newpage
    \bibliographystyle{unsrt}
    \bibliography{ref}
	
	\appendix
\end{document}