\documentclass{cacthesis}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{tabularx}

\newcounter{protocol}
\newenvironment{protocol}[1]
  {\par\addvspace{\topsep}
   \noindent
   \tabularx{\linewidth}{@{} X @{}}
    \hline
    \refstepcounter{protocol}\textbf{Protocol \theprotocol} #1 \\
    \hline}
  { \\
    \hline
   \endtabularx
   \par\addvspace{\topsep}}

\newcommand{\sbline}{\\[.5\normalbaselineskip]}% small blank line

\begin{document}

	\frontmatter
	
	%%%%%%%%%%%%%
	%% Title page
	%%%%%%%%%%%%%
	\title{Fair Exchange Protocol over Bitcoin}
	\author{Leandro Rometsch}
	\date{October 19, 2020}
	\subject{Bachelor Thesis}
	
	\publishers{
		\small
		\begin{tabular}{r l}
			Supervisors: Benjamin Schlosser, \\ Prof. Sebastian Faust, Ph.D.
		\end{tabular}
	}
	\maketitle
	
	\tableofcontents
	
	\mainmatter
	
	\chapter{Introduction}
        %Sum up the basics of a data exchange protocol. Talk about the possibilities of smart contracts, how they can realize data exchange protocols, and why Bitcoin based smart contracts might be a good alternative to Ethereum based ones. 
        
        Lets assume somebody is willing to spend money in exchange for a product. This person usually got an expectation of the product beforehand. In a traditional setting, the buyer can check for himself before paying if the product he planned to buy is actually in the expected condition. If the expectation is not met, the buyer will not pay for it, and the product could be bought by somebody else. Neither the buyer nor the merchant got a disadvantage. \\
        This procedure is not trivially transferable to a digital setting - especially if digital goods are being sold. The buyer of a digital product $D$ still got a certain expectation - we will assume this expectation is met if the predicate $\sigma\left( D\right) =1$. The dilemma is the following: Either, the merchant needs to reveal its digital commodity $D'$ first to let the buyer check if $\sigma\left( D'\right) =1$, or the buyer needs to pay beforehand without being able to inspect $D'$. Without trust among the two parties, this is undoubtedly vulnerable to fraud. \\ 
        One way to solve this dilemma is to introduce a middleman, some kind of Trusted Third Party (TTP) to the exchange - similar to Certification Authorities that issue digital certificates. The TTP can independently verify if the buyers expectation $\sigma$ is fulfilled and secure a fair exchange. Unfortunately, a dedicated middleman comes with significant drawbacks: Some service like this is most likely expensive, both parties need to agree on a specific one, and the availability is questionable. \\
        Cryptocurrencies offer huge potential here, with their smart contracts imitating the middleman. The buyer and the merchant do not need to trust a single entity anymore. The only construct to trust is the decentralized blockchain of the used cryptocurrency (and the smart contracts code). The main difficulty here is that memory is financially limited on the blockchain. The naive approach of letting a smart contract evaluating sigma with the full D' is feasible if D' consists of only a few bytes but practically fail for larger files due to high fees. Using smart contracts to support the exchange of larger files requires a different protocol design - there are good solutions out there, but more on this in the next section. \\ 
        For a fair exchange protocol deciding on a particular cryptocurrency, an important aspect is the number of users the currency got. Choosing a cryptocurrency with a big user base increases the real-life value of the protocol. The two major players here are Bitcoin and Ethereum. They both offer two completely distinct approaches when it comes to the development of "smart contracts". Ethereum, on the one hand, offers a powerful virtual machine that allows the development of complex protocols via its contract-oriented programming language. These possibilities motivate protocols to do much computation inside the smart contract, concerning high fluctuating Ethereum fees\footnote{\url{https://decrypt.co/36501/ethereum-transaction-fees-are-rising-too-high}} based on its network congestion, not necessarily a good thing. Bitcoin, on the other hand, "only" supports basic payment transactions based on a simple stack-based scripting language. Usually, fair exchange protocols utilizing Bitcoin are less efficient or lack a high fairness guarantee. \\
        This paper aims to analyze whether it is possible to construct an efficient and cheap fair exchange protocol on top of Bitcoin. We will look into efficient Ethereum based protocols and investigate the possibility of transferring one to Bitcoin, making it accessible for a broader market.
        
        \section{Current solutions}
        Briefly write about the interesting fair exchange protocols I reviewed in the research phase. What is the most exciting aspect of them? What can we learn from them?
        
        
        
        \section{Contribution}
        Understanding the current concept of fairness (and the problems relating to it). \\
        What is necessary to convert a script like FairSwap onto a potentially cheaper Bitcoin variant, and why it is challenging.
        FairSwap inspired fair exchange protocol that runs cheaper on Bitcoin Script.

        \section{Related Work}
        How Bitcoin evolved to Bitcoin Cash. What are the key differences between Bitcoin, Bitcoin Cash, and Ethereum in terms of smart contracts?.
    
    \chapter{Preliminaries}
        \section{Bitcoin}
        In 2008 Satoshi Nakamoto proposed the first practical decentralized peer-to-peer currency system (commonly known as "cryptocurrency"), named Bitcoin \cite{nakamoto2009bitcoin}. The premise of Bitcoin is a shared data structure maintained by a decentralized network of nodes. This data structure is made out of cryptographically chained blocks, the so-called blockchain, that miners continuously work on extending. One new block added to the blockchain allows for a certain amount of new payment transactions and simultaneously increases the integrity of the blocks before. Other cryptocurrencies might extend their blockchain differently. However, in Bitcoin's case, this \textit{proof-of-work} approach is used, such that the blockchain's integrity is guaranteed, as long as the honest nodes control more than half of the CPU power. For the computational burden the miners take, they are compensated with newly generated Bitcoins and transaction fees. The result is a self-sustaining system that is fully decentralized and trustable. From a high level, Bitcoin can be considered as an emulated trusted bank without a single entity controlling it.  The trust in Bitcoin is exceptionally high because there were practically no successful attacks yet. This fact is essential for the acceptability of a decentralized currency system because no central institution could be held liable. The users' trust rests in the \textit{proof-of-work} consensus protocol that secures the validity of transactions and prevents double-spending. \\
        It is notable that Bitcoins blockchain only stores transactions of Bitcoins (and some metadata to secure the blockchain) and only implicitly stores the user's balances. The name Bitcoin might be misleading here because there are no actual coins, only a traceable path of transactions that originate from a miner's reward. The amount of Bitcoin one person owns can be calculated by looking at every transaction this person received but did not spend jet. If a person wants to perform a Bitcoin transaction, it needs access to at least one key pair containing one public key and one private key. The public key is essentially the person's address, which enables him/her to receive Bitcoins. The private key is needed to send Bitcoins to other users' public keys. Because everybody can create arbitrary key-pairs without providing any personal information, Bitcoin provides some anonymity for its users. \\
        The introduction of Bitcoin, especially the blockchain concept, kickstarted many other cryptocurrencies and blockchain-based applications. Still, Bitcoin is the most widely accepted cryptocurrency and remains the largest by market capitalization\footnote{Source: \url{https://coinmarketcap.com/} (14.12.2020)} - followed by Ethereum and XRP.

        \subsection{BTC Transactions}
        Technically there are no Bitcoins, only transactions of a particular Bitcoin value that are either spent or unspent. Each new transaction needs at least one input transaction. The sum of the value of all input transactions determines the value of the new transaction. Once a transaction is published in a new block on the blockchain, its input transaction(s) are considered spent. A new transaction itself is unspent until it is again used for some other valid transaction as input. Only unspent transactions can be used as an input transaction. If one of the input transactions is already spent, the new transaction is recognized as invalid and rejected by the network. \\
        The other two essential parts of every Bitcoin transaction are the out script and the witness. The out script contains the condition(s) that need to be fulfilled by somebody that wants to spend the transaction. The witness is the values that are given as input to the out script. Consequently, the out script is the lock of a transaction, and the witness is the key. Note that the witness inside a transaction is not related to its own out script - it is needed to unlock the out script of the input transaction(s). Therefore, if the user knows the correct values to fulfill the out script of an unspent transaction, it practically owns the particular Bitcoins. Take \ref{fig:tx1} as an example. The out script is written in Bitcoin's scripting language (see next section) and is usually utilized to perform standard payments to a single Bitcoin address (P2PKH). More complex out scripts are possible that enable payments under a wide variety of conditions, e.g., timelocks or the signatures of multiple users.
        \begin{figure}
          \includegraphics[width=\linewidth]{images/basic_transaction_figure.png}
          \caption{Example of a Bitcoin transaction trace.}
          \label{fig:tx1}
        \end{figure}
        \\ For an efficient transaction validity evaluation, each node stores, in addition to the blockchain (or parts of it), two transaction pools locally: The pending transaction pool and the unspent transaction pool. Pending transactions are valid transactions requested for execution but are not included in a blockchain block yet. If a node receives a new valid transaction from a user, the node puts it into its pending transaction pool and forwards it to all connected peers. Once a new block is added to the blockchain, a node deletes all transactions the new block contains from its pending transaction pool and updates its unspent transaction pool. Suppose a node wants to evaluate the validity of the input transactions of a new transaction. In that case, it checks if all input transactions are available in the unspent transaction pool - if this is not the case, the new transaction is rejected. This procedure ensures that a node does not need to search through the whole blockchain each time a new transaction is submitted. \\

        
        \subsection{BTC Script}
        Explain Bitcoin Script basics here. What important opcodes are there? Give tx examples.
        \subsection{Bitcoin Cash}
        Hard fork.
        
        \section{FairSwap}
        Explain FairSwap in more detail. What level of fairness is archived? Write about the protocols cryptography building blocks (Merkle Proofs, concise proof of misbehavior, ...). Sum up how the protocol got implemented and give a statement about its performance. Do not mention any approaches on how to move this protocol to Bitcoin yet.
        
        \section{Building Blocks}
        \subsection{Symmetric Encryption}
        \subsection{Merkle Tree}

    \chapter{Fairness in Exchange Protocols}
        Bentov and Kumaresan state that a fair exchange protocol is a particular subcase of secure multiparty computation \cite{10.1007/978-3-662-44381-1_24}. Numerous multiparty computation protocols want to achieve a notion of security that is requiring a form of fairness. One common way of defining fairness, in this case, is \textit{if one party receives their expected output, then so do all} \cite{10.1007/978-3-540-79263-5_8}. Cleve showed in \cite{10.1145/12130.12168} that it is impossible to achieve this notion of fairness when there is no honest majority among the protocol participants. Let us carry this knowledge into the context of a two-party exchange protocol: At the point where there is one dishonest party involved, it is impossible to achieve the mentioned form of fairness. Consequently, it is crucial to specify acceptable alternative notions of fairness that are specially tailored for the two-party case. 
        
        \section{Challenges and the Superficial Notion of Fairness}
		The obstacle when using the construct of \textit{fairness} is that various interpretations among different points of view exist. Markowitch et al. stated that it is crucial for defining fairness in exchange protocols to focus on what fairness is and not on how to obtain it \cite{10.1007/3-540-36552-4_31}. It is obvious to claim that a \textit{fair} exchange protocol requires that no party gains a \textit{significant advantage} over the other party under the limitation of particular assumptions. Different explanations of what is meant with a \textit{significant advantage} result in different fairness notions. \\
        The primary definition commonly used among publications around fair exchange protocols (like \cite{10.1145/266420.266426} \cite{asyncOptiFairEx1998} \cite{remarksOnFairEx2000})  is the following: \textit{At the end of every exchange protocol run, either all involved parties obtain their expected information/asset, or none of them receives anything.} This definition might be satisfying in some scenarios, but \textit{advantage} is defined minimally and only focuses on the actual exchange result here. In other words, this definition could be interpreted as some superficial notion of fairness.
        
        \section{Imaginary Scenario}
        Let us imagine the following scenario: $B$, the buyer, and $S$, the seller, use a fair exchange protocol $P$ to trade some digital coins for a digital item. The high-level procedure of $P$ is as follows: $B$ locks up digital coins that $B$ is willing to spend for a particular digital item $D$ that satisfies the predicate $\sigma$ s.t. $\sigma\left( D\right) =1$. The digital coins can be redeemed by $S$ if $S$ can deliver a digital item $D'$ s.t. $\sigma\left( D'\right) =1$. If $S$ can do this, $B$ can be sure that $D' = D$ and both parties are satisfied. If $S$ is not responding with a matching $D'$, the previously locked-up coins will be available for $B$ again after a pre-defined timeframe $t$, and $S$ cannot claim them anymore. \\
        In the sense of the above-defined superficial notion of fairness, this protocol is fair because there are only two possible outcomes of $P$. Either the exchange succeeded or non of the parties receives anything. 
        Although $P$ is certainly fair under this definition, $B$ got a significant disadvantage. $B$ cannot use the coins for something else during the execution of $P$, and a malicious $S$ could use this knowledge, e.g., for a DOS attack. One could argue that this is not fair because one party got a \textit{significant advantage} over the other party. Therefore giving definitions for different notions of fairness comes hand-in-hand with defining advantage. This is, unfortunately, missing in our mentioned superficial notion of fairness. 
        
        \section{Defining "Advantage"}
        While explaining \textit{advantage} in the context of fair exchange protocols Markowitch et al. come up with three main aspects that make up different notions of fairness \cite{10.1007/3-540-36552-4_31}. (1) \textbf{Fairness}, directly relating to the items being exchanged during the protocol. (2) \textbf{Timeliness}, relating to determining the progress of a protocol and the option to abort it at some point while preserving fairness. (3) \textbf{Abuse-freeness}, in that sense, that no single party alone can prove to an outside one that he has the power to terminate or complete the protocol successfully. A specific notion of fairness might consider one aspect stronger, weaker, or even irrelevant. \\
        Projecting these aspects on our imaginary exchange protocol $P$: (1) is undoubtedly fulfilled because either the exchange succeeded or non of the parties receives anything. (2) is only partially fulfilled because $S$ might be able to abort by not responding, but $B$ must wait until the coins are unlocked. $B$ is also not able to determine the progress of the protocol. $S$ might be preparing the transmission of $D'$ or already aborted. Either way, the protocol is time-wise limited by the pre-defined timeframe $t$. (3) is not fulfilled. If $S$ indeed owns $D'$ s.t. $\sigma\left( D'\right) =1$, $S$ can prove to an outside party that $S$ has the power to terminate or complete $P$ successfully, at least inside the timeframe until $B$ can unlock the coins again. $S$ can abuse $P$ for the only purpose of blocking $B$'s coins for a particular time - even if $S$ does not know $D$.
        
        \section{Strong Fairness, Weak Fairness}
        Another common notion of fairness is \textit{Strong Fairness}, sometimes referred to as perfect fairness. Pagnia and Gaertner created an early formal definition for \textit{Strong Fairness} in exchange protocols \cite{Pagnia99onthe}. They are essentially stating that both parties got some expectation from the goods being exchanged, much like the predicate $\sigma$ of our imaginary protocol $P$. \textit{At the end of the protocol run, either both parties expectations are being fulfilled after the exchange protocol, or no information about the other party's respective good is gained.} This sounds a lot like the previously mentioned superficial notion of fairness. Indeed it is equivalent, but the modern usage of \textit{Strong Fairness} goes beyond this: \textit{A single party cannot leave the protocol with even a small advantage over the opponent} \cite{DELGADOSEGURA2020832}. Again, this is not absolute and only valuable if \textit{advantage} is adequately defined, for example, by the three aspects mentioned. \\
        It is worth mentioning that some publications expect from their notion of \textit{Strong Fairness} that it should always be possible for the buyer to retrieve the original expected item in case of a problem, without needing the misbehaving party to cooperate \cite{DELGADOSEGURA2020832}. For our imaginary protocol $P$, this is not the case and would require a different approach. Usually, this is achieved by heavyweight Trusted Third Parties ($TTP$). This $TTP$ could take $D$ from $S$ as an initial step in $P'$ and check if the expectation $\sigma$ is fulfilled. B only proceeds if the $TTP$ approves. The protocol $P'$ could then run as defined in $P$ with the small addition that if $S$ is not providing $D$ until $t$ by itself, the $TTP$ will send a copy of $D$ to $B$ and finish the exchange. However, there exist optimistic protocols using transparent Trusted Third Parties that are used to maintain this notion of \textit{Strong Fairness} \cite{6982058} \cite{10.1007/3-540-36552-4_31}. \\
        While in \textit{Strong Fairness} usually, an honest party does not need to get active to prove its honesty in case of a dispute, in \textit{Weak Fairness} an honest party can prove his honesty to an external judge, like a TTP \cite{10.1007/3-540-36552-4_31}. The external judge can then evaluate the dispute. If the potentially misbehaving party is not cooperating, the honest party receives some compensation. A protocol achieving \textit{Weak Fairness} is therefore dependent on the external judge's honesty.
        
        \section{Probabilistic Fairness}
        Finally, there are Fair Exchange Protocols that merge their notion of fairness with probability. These are usually protocols that depend on techniques that offer a probability of fairness (e.g., cut-and-choose in \cite{DELGADOSEGURA2020832}) based on the chosen security parameters. This approach is challenging to classify in our existing idea of fairness. The most consistent one is that we recognize \textit{Probabilistic Fairness} as a relativization to already defined notions of fairness since most definitions can be easily shifted into a probabilistic context. Let us do this for our previously mentioned superficial notion of fairness: \textit{For an adequate security parameter k, at the end of the exchange protocol run there must be an overwhelming probability that either all parties obtain their expected information or non of the parties obtain anything.} \\
        To further elaborate on this, we project this again on our imaginary protocol $P$. We construct a new protocol $P''$ that replaces the previous predicate $\sigma$ with a cut-and-choose procedure. $S$ now needs to provide a $D'$ that is split up into $n$ parts. $B$ chooses $k < n$ indices $K$. These indices are not known by $S$. For a successful exchange, $S$ needs to provide a $D'$ s.t. $\forall i\in K:\sigma'\left( D_{i}'\right) =1$. \\

        
        %\section{Fairness techniques} 
        % Gradiual Release, Claim-or-refund, cut-and-choose.
        % maybe https://eprint.iacr.org/2005/370.pdf also interesting
		
	\chapter{Our construction}
	   
	   \newpage
	   \section{FairSwap to Bitcoin}
        What is necessary to move FairSwaps Ethereum implementation to Bitcoin Script and why it is not straight forward? How did we solve the problems on a high level? 
        
        \subsection{Merkle Tree based Refund Transactions}
        De facto a single valid Refund Transaction is an concise proof of misbehavior. Additionally introduce the Lockup Tx here.
        
        \subsection{Key Exchange Transaction}
        De facto a single valid Refund Transaction is an concise proof of misbehavior.
        
        \section{The protocol}
        Combine the building blocks mentioned in the Preliminaries to form a formal version of the protocol.
                    \begin{algorithm}[H]
            \SetAlgoLined
             \ForEach{$i \in [c]$}{
              $k_i = H(k \| i)$\;
              $ex_i = k_i \oplus x_i$\;
              }
              $ex = (ex_1,..., ex_c)$\;
              $M_x = $\textit{Mtree}$(x)$\;
              $c_k = H(k)$\;
             \Return $(ex, M_x, c_k)$\;
        
             \caption{\textit{Encode($H, x, k$)}}
            \end{algorithm}
            
            \begin{algorithm}[H]
            \SetAlgoLined
             \ForEach{$i \in [c]$}{
              $k_i = H(k \| i)$\;
              $x_i = k_i \oplus ex_i$\;
             }
             $x = (x_1,..., x_c)$\;
             $M_x = $\textit{Mtree}$(x)$\;
             \ForEach{$i \in [c]$}{
              \If{\textit{Mproof}$(x_i, M_x) == \perp$}{
               \Return $(x, i)$\;
               }
             }
             \Return $(x, \perp)$\;
             \caption{\textit{Decode($H, ex, k$)}}
            \end{algorithm}
            
        
        \begin{protocol}{Fair Exchange Protocol with honest parties}
        \textit{Inputs.} (Hash-Function, Security parameter, Number of chunks, \textit{Mroot}(x), price) = $(H, n, c, H_x, p)$
        \sbline
        \textit{Goal.} Seller $S$ receives $p$ coins from Buyer $B$ in exchange for a digital item $x$.
        \sbline
        \textit{The protocol:}
        \begin{enumerate}
          \item \textbf{Setup.}
          \begin{enumerate}
            \item S generates secret key $k$ $\leftarrow$ $(0, 1)^n$ uniformly at random.
            
            \item S divides digital item $x$ in $c$ parts and computes $([ex], M_x, commit_k)$ $\leftarrow$ \textsf{Encode($H, [x], k$)}.
            
            \item S creates Locking-Transaction $LTX$ $\leftarrow$ \textsf{GenLockingTx($S_{pk}, B_{pk}, p$)} and publishes the transaction to the Blockchain.
            
            \item For each $i \in [c]$, S creates a new Refund Transactions $SRT_i$ $\leftarrow$ \textsf{GenRefundTx($S_{pk}, B_{pk}, H(LTX), H(ex_i), i, commit_k, p$)} $\in [SRT]$. S sends the Set of Refund Transactions $[SRT]$ to B.
            
            \item B evaluates \textsf{ConsistencyCheck($[SRT], H_x, p, S_{pk}, B_{pk}$)} and checks for $LTX$ on the Blockchain.
          \end{enumerate}
          
          \item \textbf{Exchange.}
          \begin{enumerate}
            \item B creates Claim-Transaction $CTX$ $\leftarrow$ \textsf{CreateClaimTx($S_{pk}, B_{pk}, H, commit_k, p$)} and publishes it to the Blockchain.
            
            \item S provides $k$ to CTX (s.t. $H(k) = commit_k$) and earns p coins
          \end{enumerate}
          
          \item \textbf{Data Evaluation.}
          \begin{enumerate}
            \item B computes $([x], i)$ $\leftarrow$ \textsf{Decode($H, [ex], k$)}. If $i = \perp$ the exchange was successful. Finally B concatenates all elements of [x] to receive x.
          \end{enumerate}
        
        \end{enumerate}
        
        \end{protocol}
        
        \section{Fairness discussion}
	    Connect the findings of the Fairness section with the actual fairness of the finish protocol.
	    
	    \section{Security}
	    Informal security analysis - discuss various attack vectors.
	    
	\chapter{Implementation}
	    Details about the implementation
	    \section{Tools}
	    
	    \section{Evaluation}
	    Compare costs of protocol (computational costs \& fees) with FairSwap.
	    
	\chapter{Conclusion}
    
	
	\newpage
    \bibliographystyle{unsrt}
    \bibliography{ref}
	
	\appendix
\end{document}